/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.mulesoft.support;

import java.io.*;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.commons.lang.StringUtils;
import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.MuleMessage;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.Source;
import org.mule.api.annotations.lifecycle.Start;
import org.mule.api.annotations.lifecycle.Stop;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.callback.SourceCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generic module
 *
 * @author MuleSoft, Inc.
 */
@Connector(name = "vmx", schemaVersion = "1.0.0", minMuleVersion = "3.3.1", friendlyName = "Inter-app VM")
public class InterappEndpointsModule {

    private static final String INITIAL_CONTEXT_FACTORY_CLASS = "com.mulesoft.support.InterappInitialContextFactory";
    private static final String JNDI_PREFIX = "java:global/env/apps/";
    private static final Logger logger = LoggerFactory.getLogger(InterappEndpointsModule.class);
    private Context context;
    private boolean isStarted;
    private String currentPath;
    private ObjectInputStream inputPipe;

    /**
     * Initialize the initial context used by this module to publish and
     * subscribe to interapp queues.
     *
     */
    @Start
    public void init() {
        Hashtable<String, String> env = new Hashtable<String, String>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, INITIAL_CONTEXT_FACTORY_CLASS);
        try {
            context = new InitialContext(env);
        } catch (NamingException nex) {
            logger.error("Got NamingException while starting VMX module", nex);
            throw new RuntimeException(nex);
        }
    }
    
    /**
     * Register a listening pipe for the given path.
     * @param path the path of the virtual queue where this endpoint will be
     * listening to.
     * @throws ConnectionException 
     */
    public void doConnect(String path) throws ConnectionException {
        if (StringUtils.isEmpty(path)) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }
        
        if (StringUtils.isNotBlank(this.currentPath)) {
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, "500", "This endpoint is already connected!");
        }
        
        try {
            this.inputPipe = activatePipesForPath(path);
            this.currentPath = path;
            isStarted = true;
        } catch (IOException ex) {
            logger.error("Got IOException while trying to register a listening pipe", ex);
            throw new ConnectionException(ConnectionExceptionCode.CANNOT_REACH, "500", "Cannot register pipe", ex);
        } catch (RuntimeException ex) {
            logger.error("Got RuntimeException while trying to register a listening pipe", ex);
            throw new ConnectionException(ConnectionExceptionCode.CANNOT_REACH, "500", "Cannot register pipe", ex);
        }
    }
    
    /**
     * Take care of properly releasing resources. (Only for inbound endpoints)
     */
    @PreDestroy
    public void doDisconnect() {

        if (StringUtils.isEmpty(currentPath)) {
            return;
        }

        logger.info("Cleaning up path..." + currentPath);

        safeCloseStream(inputPipe);
        removeFromJndi(currentPath);
    }

    /**
     * Inbound endpoint for the interapp messages.
     *
     * {@sample.xml ../../../doc/interapp-endpoint-module-connector.xml.sample vmx:inbound-endpoint}
     * 
     * @param path the path of the virtual queue where this endpoint will be
     * listening to.
     * @param callback the callback to activate the message pipeline.
     * @throws ConnectionException if connecting the endpoint fails.
     */
    @Source
    public void inboundEndpoint(@ConnectionKey String path, final SourceCallback callback) throws ConnectionException {
        
        doConnect(path);
        
        while (isStarted) {
            try {

                //read the mule message
                MuleMessage message = (MuleMessage) inputPipe.readObject();

                if (!isStarted) {
                    //this might happen when shutting down.
                    break;
                }

                //dispatch.
                callback.process(message.getPayload(), extractOutboundProperties(message));

            } catch (Exception ex) {
                logger.error("Got unknown exception while listening for new messages", ex);
                isStarted = false;
            }
        }

        logger.info("Endpoint " + currentPath + " is not listening any longer.");
    }

    /**
     * Dispatch a message to other application which is listening at the given
     * path.
     *
     * {@sample.xml ../../../doc/interapp-endpoint-module-connector.xml.sample vmx:outbound-endpoint}
     *
     * @param path The path of the virtual queue where this endpoint will be 
     * postig to.
     * @param message The message to send.
     * @return the same message as the given argument.
     */
    @Inject
    @Processor
    public MuleMessage outboundEndpoint(String path, MuleMessage message) {

        if (StringUtils.isEmpty(path)) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }

        ObjectOutputStream os = getFromJndi(path);

        if (os == null) {
            throw new IllegalStateException("Target application is not connected");
        }

        try {
            //write the message and move on.
            os.writeObject(message);

        } catch (IOException ex) {
            logger.error("Got IOException while dispatching message", ex);
            //it is not the responsibility of this end to close the streams.
            //rethrow the exception for proper handling.
            throw new RuntimeException(ex);
        }
        return message;
    }

    private synchronized ObjectInputStream activatePipesForPath(String path) throws IOException {

        //trying to register an inbound endpoint with the same path
        //not allowed
        if (getFromJndi(path) != null) {
            throw new IllegalStateException("Inbound endpoint already registered path " + path);
        }

        ObjectInputStream ret;

        //we may proceed to create the pipes.
        PipedInputStream is = new PipedInputStream();

        //connect the pipe
        OutputStream os = new PipedOutputStream(is);

        //register directly as object output stream
        os = new ObjectOutputStream(os);
        ret = new ObjectInputStream(is);

        //register the pipes on the respective registries.
        registerInJndi(path, os);

        return ret;

    }

    /**
     * Lookup objects on the jndi directory.
     *
     * @param <T> The return type
     * @param path the path on the directory.
     * @return the desired object or null if not found.
     */
    private <T> T getFromJndi(String path) {
        try {
            return (T) context.lookup(JNDI_PREFIX + path);
        } catch (NamingException nex) {
            //does not exist, no harm
            return null;
        }
    }

    /**
     * Register an object in the JNDI context.
     *
     * @param path the key for storing the object.
     * @param object the object to store.
     */
    private void registerInJndi(String path, Object object) {
        try {
            context.bind(JNDI_PREFIX + path, object);
        } catch (NamingException nex) {
            //this is also bad
            throw new RuntimeException(nex);
        }
    }

    /**
     * Remove an object from the JNDI context.
     *
     * @param path
     */
    private void removeFromJndi(String path) {
        try {
            context.unbind(JNDI_PREFIX + path);
        } catch (NamingException nex) {
            //just ignore the failed attempt and log it as debug.
            if (!logger.isDebugEnabled()) {
                return;
            }

            logger.debug("Got naming exception while trying to remove " + path, nex);
        }
    }

    /**
     * Extract the outbound properties of a message.
     *
     * @param message the message whos properties will be extracted.
     * @return a map containing the outbound properties.
     */
    private Map<String, Object> extractOutboundProperties(MuleMessage message) {

        HashMap<String, Object> ret = new HashMap<String, Object>();

        for (String prop : message.getOutboundPropertyNames()) {
            ret.put(prop, message.getOutboundProperty(prop));
        }

        return ret;
    }

    private void safeCloseStream(InputStream stream) {
        try {
            stream.close();
        } catch (IOException ex) {
            //exceptions at this point only logged in debug.
            if (!logger.isDebugEnabled()) {
                return;
            }
            logger.debug("Gor exception while closing stream...", ex);
        }
    }
}
