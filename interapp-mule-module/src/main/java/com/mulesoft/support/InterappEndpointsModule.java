/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.mulesoft.support;

import java.io.*;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.commons.lang.StringUtils;
import org.mule.api.MuleMessage;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.Source;
import org.mule.api.callback.SourceCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generic module
 *
 * @author MuleSoft, Inc.
 */
@Module(name = "vmx", schemaVersion = "1.0.0")
public class InterappEndpointsModule {

    private static final String INITIAL_CONTEXT_FACTORY_CLASS = "com.mulesoft.support.InterappInitialContextFactory";
    private static final String JNDI_PREFIX = "java:global/env/apps/";
    private static final Logger logger = LoggerFactory.getLogger(InterappEndpointsModule.class);
    private Context context;
    private boolean isStarted;
    private ConcurrentHashMap<String, PipedInputStream> currentPipes;

    /**
     * Initialize the initial context used by this module to publish and
     * subscribe to interapp queues.
     * 
     */
    @PostConstruct
    public void init() {
        Hashtable<String, String> env = new Hashtable<String, String>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, INITIAL_CONTEXT_FACTORY_CLASS);
        try {
            context = new InitialContext(env);
            isStarted = true;
            currentPipes = new ConcurrentHashMap<String, PipedInputStream>();
        } catch (NamingException nex) {
            logger.error("Got NamingException while starting VMX module", nex);
            throw new RuntimeException(nex);
        }
    }

    /**
     * Take care of properly releasing resources.
     */
    @PreDestroy
    public void release() {
        //go through the pipes, close them and remove the other end from the initial context.
        for(String key : currentPipes.keySet()) {
            PipedInputStream is = currentPipes.get(key);

            safeCloseStream(is);

            removeFromJndi(key);
        }

        currentPipes.clear();
    }

    /**
     * Inbound endpoint for the interapp messages.
     * 
     * {@sample.xml ../../../doc/interapp-endpoint-module-connector.xml.sample vmx:inbound-endpoint}
     * 
     * @param path the path of the virtual queue where this endpoint will be
     * listening to.
     * @param callback the callback to activate the message pipeline.
     */
    @Source
    public void inboundEndpoint(String path, final SourceCallback callback) {

        if (StringUtils.isEmpty(path)) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }

        PipedInputStream stream = activatePipes(path);

        while (isStarted) {
            try {
                ObjectInputStream is = new ObjectInputStream(stream);

                //read the mule message
                MuleMessage message = (MuleMessage) is.readObject();

                if (!isStarted) {
                    //this might happen when shutting down.
                    break;
                }

                //dispatch.
                callback.process(message.getPayload(), extractOutboundProperties(message));

            } catch (Exception ex) {
                logger.error("Got unknown exception while listening for new messages", ex);
                isStarted = false;
            }
        }

    }

    /**
     * Dispatch a message to other application which is listening at the given path.
     *
     * {@sample.xml ../../../doc/interapp-endpoint-module-connector.xml.sample vmx:outbound-endpoint}
     *
     * @param path The
     * @param message The message to send.
     * @return the same message as the given argument.
     */
    @Inject
    @Processor
    public MuleMessage outboundEndpoint(String path, MuleMessage message) {

        if (StringUtils.isEmpty(path)) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }

        PipedOutputStream pipedOs = getFromJndi(path);

        if (pipedOs == null) {
            throw new IllegalStateException("Target application is not connected");
        }

        try {

            ObjectOutputStream os = new ObjectOutputStream(pipedOs);
            //write the message and move on.
            os.writeObject(message);

        } catch (IOException ex) {
            logger.error("Got IOException while dispatching message", ex);
            //it is not the responsibility of this end to close the streams.
            //rethrow the exception for proper handling.
            throw new RuntimeException(ex);
        }
        return message;
    }

    private synchronized PipedInputStream activatePipes(String path) {

        //trying to register an inbound endpoint with the same path
        //not allowed
        if (currentPipes.containsKey(path) || getFromJndi(path) != null) {
            throw new IllegalStateException("Inbound endpoint already registered path" + path);
        }

        try {

            //we may proceed to create the pipes.
            PipedInputStream is = new PipedInputStream();

            //connect and register
            PipedOutputStream os = new PipedOutputStream(is);

            //register the pipes on the respective registries.
            currentPipes.put(path, is);

            registerInJndi(path, os);

            return is;

        } catch (IOException ex) {
            //at this point if there is something wrong with the pipes
            //then it should be something really bad.
            throw new RuntimeException(ex);
        }
    }

    /**
     * Lookup objects on the jndi directory.
     *
     * @param <T> The return type
     * @param path the path on the directory.
     * @return the desired object or null if not found.
     */
    private <T> T getFromJndi(String path) {
        try {
            return (T) context.lookup(JNDI_PREFIX + path);
        } catch (NamingException nex) {
            //does not exist, no harm
            return null;
        }
    }

    /**
     * Register an object in the JNDI context.
     *
     * @param path the key for storing the object.
     * @param object the object to store.
     */
    private void registerInJndi(String path, Object object) {
        try {
            context.bind(JNDI_PREFIX + path, object);
        } catch (NamingException nex) {
            //this is also bad
            throw new RuntimeException(nex);
        }
    }

    /**
     * Remove an object from the JNDI context.
     * @param path
     */
    private void removeFromJndi(String path) {
        try {
            context.unbind(JNDI_PREFIX + path);
        } catch (NamingException nex) {
            //just ignore the failed attempt and log it as debug.
            if (!logger.isDebugEnabled()) {
                return;
            }

            logger.debug("Got naming exception while trying to remove " + path, nex);
        }
    }

    /**
     * Extract the outbound properties of a message.
     *
     * @param message the message whos properties will be extracted.
     * @return a map containing the outbound properties.
     */
    private Map<String, Object> extractOutboundProperties(MuleMessage message) {

        HashMap<String, Object> ret = new HashMap<String, Object>();

        for (String prop : message.getOutboundPropertyNames()) {
            ret.put(prop, message.getOutboundProperty(prop));
        }

        return ret;
    }

    private void safeCloseStream(InputStream stream) {
        try {
            stream.close();
        } catch (IOException ex) {
            //exceptions at this point only logged in debug.
            if (!logger.isDebugEnabled()) {
                return;
            }
            logger.debug("Gor exception while closing stream...", ex);
        }
    }
}
